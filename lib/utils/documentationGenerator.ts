import { DockerCompose } from '@/types/dockerCompose';
import { ConversionOptions } from '@/types/project';

/**
 * Documentation Generator
 * Generates README.md and .env.example files
 */
export class DocumentationGenerator {
  /**
   * Generate comprehensive README.md
   */
  static generateREADME(
    projectName: string,
    dockerCompose: DockerCompose,
    options: ConversionOptions
  ): string {
    const services = Object.keys(dockerCompose.services);
    const hasKubernetes = options.targetPlatform === 'kubernetes' || options.targetPlatform === 'both';
    const hasSwarm = options.targetPlatform === 'swarm' || options.targetPlatform === 'both';

    let readme = `# ${projectName}\n\n`;
    readme += `> Production-ready deployment configurations generated by DevOps Deployment Accelerator\n\n`;

    // Project Overview
    readme += `## üìã Project Overview\n\n`;
    readme += `This project contains production-ready deployment configurations for **${projectName}**.\n\n`;
    readme += `**Services (${services.length}):**\n`;
    services.forEach(service => {
      const svc = dockerCompose.services[service];
      readme += `- \`${service}\`: ${svc.image || 'custom build'}\n`;
    });
    readme += `\n`;

    // Configuration Summary
    readme += `**Configuration:**\n`;
    readme += `- Target Platform: ${options.targetPlatform === 'both' ? 'Kubernetes & Docker Swarm' : options.targetPlatform}\n`;
    readme += `- Reverse Proxy: ${options.proxyType === 'none' ? 'None' : options.proxyType.charAt(0).toUpperCase() + options.proxyType.slice(1)}\n`;
    readme += `- Health Checks: ${options.addHealthChecks ? 'Enabled' : 'Disabled'}\n`;
    readme += `- Resource Limits: ${options.addResourceLimits ? `Enabled (${options.resourceProfile || 'medium'})` : 'Disabled'}\n`;
    readme += `- Security Hardening: ${options.addSecurity ? 'Enabled' : 'Disabled'}\n\n`;

    // Prerequisites
    readme += `## ‚öôÔ∏è Prerequisites\n\n`;
    if (hasKubernetes) {
      readme += `### Kubernetes\n`;
      readme += `- [kubectl](https://kubernetes.io/docs/tasks/tools/) v1.28 or higher\n`;
      readme += `- Access to a Kubernetes cluster (local: minikube, kind, k3s; cloud: GKE, EKS, AKS)\n`;
      readme += `- \`kubectl config\` configured to connect to your cluster\n\n`;
    }
    if (hasSwarm) {
      readme += `### Docker Swarm\n`;
      readme += `- [Docker](https://docs.docker.com/get-docker/) v20.10 or higher\n`;
      readme += `- Docker Swarm initialized: \`docker swarm init\`\n`;
      readme += `- Access to Docker Swarm manager node\n\n`;
    }

    // Kubernetes Deployment
    if (hasKubernetes) {
      readme += `## ‚ò∏Ô∏è Kubernetes Deployment\n\n`;
      readme += `### 1. Review and Customize\n\n`;
      readme += `Review the generated Kubernetes manifests in the \`kubernetes/\` directory:\n\n`;
      readme += `\`\`\`bash\n`;
      readme += `ls -la kubernetes/\n`;
      readme += `\`\`\`\n\n`;

      readme += `### 2. Deploy to Kubernetes\n\n`;
      readme += `Apply all manifests to your cluster:\n\n`;
      readme += `\`\`\`bash\n`;
      readme += `# Apply all manifests\n`;
      readme += `kubectl apply -f kubernetes/\n\n`;
      readme += `# Or apply individually\n`;
      readme += `kubectl apply -f kubernetes/deployments/\n`;
      readme += `kubectl apply -f kubernetes/services/\n`;
      readme += `kubectl apply -f kubernetes/configmaps/\n`;
      if (options.proxyType !== 'none') {
        readme += `kubectl apply -f kubernetes/ingress/\n`;
      }
      readme += `\`\`\`\n\n`;

      readme += `### 3. Verify Deployment\n\n`;
      readme += `Check the status of your deployments:\n\n`;
      readme += `\`\`\`bash\n`;
      readme += `# Check deployments\n`;
      readme += `kubectl get deployments\n\n`;
      readme += `# Check pods\n`;
      readme += `kubectl get pods\n\n`;
      readme += `# Check services\n`;
      readme += `kubectl get services\n\n`;
      readme += `# Check logs for a specific pod\n`;
      readme += `kubectl logs -f <pod-name>\n`;
      readme += `\`\`\`\n\n`;

      readme += `### 4. Access Services\n\n`;
      if (options.proxyType !== 'none') {
        readme += `Services are accessible through the ${options.proxyType} ingress:\n\n`;
        readme += `- Configure your DNS to point to the cluster ingress IP\n`;
        readme += `- Or use \`kubectl port-forward\` for local access\n\n`;
      } else {
        readme += `Access services using \`kubectl port-forward\`:\n\n`;
        services.forEach(service => {
          const svc = dockerCompose.services[service];
          if (svc.ports && svc.ports.length > 0) {
            const port = typeof svc.ports[0] === 'string'
              ? svc.ports[0].split(':')[1] || svc.ports[0]
              : svc.ports[0];
            readme += `\`\`\`bash\n`;
            readme += `kubectl port-forward service/${service} ${port}:${port}\n`;
            readme += `\`\`\`\n\n`;
          }
        });
      }
    }

    // Docker Swarm Deployment
    if (hasSwarm) {
      readme += `## üê≥ Docker Swarm Deployment\n\n`;
      readme += `### 1. Initialize Swarm (if not already done)\n\n`;
      readme += `\`\`\`bash\n`;
      readme += `docker swarm init\n`;
      readme += `\`\`\`\n\n`;

      readme += `### 2. Review Configuration\n\n`;
      readme += `Review the generated Docker Stack file:\n\n`;
      readme += `\`\`\`bash\n`;
      readme += `cat swarm/docker-stack.yml\n`;
      readme += `\`\`\`\n\n`;

      readme += `### 3. Deploy Stack\n\n`;
      readme += `Deploy your application to the swarm:\n\n`;
      readme += `\`\`\`bash\n`;
      readme += `docker stack deploy -c swarm/docker-stack.yml ${projectName.toLowerCase().replace(/[^a-z0-9-]/g, '')}\n`;
      readme += `\`\`\`\n\n`;

      readme += `### 4. Verify Deployment\n\n`;
      readme += `Check the status of your stack:\n\n`;
      readme += `\`\`\`bash\n`;
      readme += `# List stacks\n`;
      readme += `docker stack ls\n\n`;
      readme += `# List services\n`;
      readme += `docker stack services ${projectName.toLowerCase().replace(/[^a-z0-9-]/g, '')}\n\n`;
      readme += `# List tasks (containers)\n`;
      readme += `docker stack ps ${projectName.toLowerCase().replace(/[^a-z0-9-]/g, '')}\n\n`;
      readme += `# Check service logs\n`;
      readme += `docker service logs <service-name>\n`;
      readme += `\`\`\`\n\n`;
    }

    // Environment Variables
    readme += `## üîê Environment Variables\n\n`;
    readme += `The following environment variables need to be configured:\n\n`;

    const envVars = new Set<string>();
    services.forEach(service => {
      const svc = dockerCompose.services[service];
      if (svc.environment) {
        if (Array.isArray(svc.environment)) {
          svc.environment.forEach((env: string) => {
            const key = env.split('=')[0];
            envVars.add(key);
          });
        } else {
          Object.keys(svc.environment).forEach(key => {
            envVars.add(key);
          });
        }
      }
    });

    if (envVars.size > 0) {
      readme += `| Variable | Description | Required |\n`;
      readme += `|----------|-------------|----------|\n`;
      envVars.forEach(envVar => {
        readme += `| \`${envVar}\` | *Configure this value* | Yes |\n`;
      });
      readme += `\n`;
      readme += `Create a \`.env\` file or ConfigMap/Secret to provide these values.\n\n`;
    } else {
      readme += `No environment variables detected in the Docker Compose file.\n\n`;
    }

    // Accessing Services
    readme += `## üåê Accessing Services\n\n`;
    services.forEach(service => {
      const svc = dockerCompose.services[service];
      if (svc.ports && svc.ports.length > 0) {
        const port = typeof svc.ports[0] === 'string'
          ? svc.ports[0].split(':')[0]
          : svc.ports[0];
        readme += `### ${service}\n`;
        readme += `- Port: \`${port}\`\n`;
        if (options.proxyType !== 'none' && options.customDomains && options.customDomains[service]) {
          readme += `- URL: \`https://${options.customDomains[service]}\`\n`;
        }
        readme += `\n`;
      }
    });

    // Troubleshooting
    readme += `## üîß Troubleshooting\n\n`;

    if (hasKubernetes) {
      readme += `### Kubernetes\n\n`;
      readme += `**Pods not starting:**\n`;
      readme += `\`\`\`bash\n`;
      readme += `kubectl describe pod <pod-name>\n`;
      readme += `kubectl logs <pod-name>\n`;
      readme += `\`\`\`\n\n`;

      readme += `**Service not accessible:**\n`;
      readme += `\`\`\`bash\n`;
      readme += `kubectl get svc\n`;
      readme += `kubectl describe svc <service-name>\n`;
      readme += `\`\`\`\n\n`;

      if (options.addHealthChecks) {
        readme += `**Health check failures:**\n`;
        readme += `- Verify your application exposes \`/health\` and \`/ready\` endpoints\n`;
        readme += `- Check probe configuration in deployment manifests\n`;
        readme += `- Adjust \`initialDelaySeconds\` if startup is slow\n\n`;
      }
    }

    if (hasSwarm) {
      readme += `### Docker Swarm\n\n`;
      readme += `**Service not starting:**\n`;
      readme += `\`\`\`bash\n`;
      readme += `docker service ps <service-name> --no-trunc\n`;
      readme += `docker service logs <service-name>\n`;
      readme += `\`\`\`\n\n`;

      readme += `**Remove stack:**\n`;
      readme += `\`\`\`bash\n`;
      readme += `docker stack rm ${projectName.toLowerCase().replace(/[^a-z0-9-]/g, '')}\n`;
      readme += `\`\`\`\n\n`;
    }

    // Scaling
    readme += `## üìà Scaling\n\n`;
    if (hasKubernetes) {
      readme += `### Kubernetes\n`;
      readme += `\`\`\`bash\n`;
      readme += `kubectl scale deployment <deployment-name> --replicas=5\n`;
      readme += `\`\`\`\n\n`;
    }
    if (hasSwarm) {
      readme += `### Docker Swarm\n`;
      readme += `\`\`\`bash\n`;
      readme += `docker service scale <service-name>=5\n`;
      readme += `\`\`\`\n\n`;
    }

    // Footer
    readme += `---\n\n`;
    readme += `**Generated by DevOps Deployment Accelerator**\n\n`;
    readme += `For more information, visit the [documentation](https://github.com/yourusername/devops-accelerator).\n`;

    return readme;
  }

  /**
   * Generate .env.example file
   */
  static generateEnvExample(dockerCompose: DockerCompose): string {
    let envExample = `# Environment Variables\n`;
    envExample += `# Generated by DevOps Deployment Accelerator\n\n`;

    const envVars = new Map<string, string>();

    Object.entries(dockerCompose.services).forEach(([serviceName, service]) => {
      if (service.environment) {
        envExample += `# ${serviceName}\n`;

        if (Array.isArray(service.environment)) {
          service.environment.forEach((env: string) => {
            const [key, value] = env.split('=');
            if (value) {
              envExample += `${key}=${value}\n`;
            } else {
              envExample += `${key}=\n`;
            }
          });
        } else {
          Object.entries(service.environment).forEach(([key, value]) => {
            envExample += `${key}=${value || ''}\n`;
          });
        }

        envExample += `\n`;
      }
    });

    if (envExample === `# Environment Variables\n# Generated by DevOps Deployment Accelerator\n\n`) {
      envExample += `# No environment variables found in Docker Compose file\n`;
    }

    return envExample;
  }
}
