
import * as yaml from 'js-yaml';

/**
 * Caddy Configuration Options
 */
export interface CaddyOptions {
  email?: string; // For automatic HTTPS with Let's Encrypt
  enableAutoHTTPS?: boolean; // Enable automatic HTTPS (default: true)
  enableGzip?: boolean; // Enable gzip compression (default: true)
  enableLogs?: boolean; // Enable JSON logging (default: true)
  logLevel?: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR'; // Log level (default: INFO)
}

/**
 * Caddy Service Configuration
 */
export interface CaddyServiceConfig {
  serviceName: string;
  domain: string;
  port: number;
  path?: string; // Base path for routing (default: /)
}

/**
 * Caddy Generator Class
 * Generates Caddyfile configurations with automatic HTTPS
 * Caddy automatically handles SSL/TLS certificates via Let's Encrypt
 */
export class CaddyGenerator {
  /**
   * Generate Caddyfile for a single service
   */
  static generateCaddyfile(
    config: CaddyServiceConfig,
    options: CaddyOptions = {}
  ): string {
    const {
      serviceName,
      domain,
      port,
      path = '/',
    } = config;

    const {
      email,
      enableAutoHTTPS = true,
      enableGzip = true,
    } = options;

    let caddyfile = `# Caddyfile for ${serviceName}
# Generated by DevOps Deployment Accelerator

`;

    // Global options (if email provided for Let's Encrypt)
    if (email && enableAutoHTTPS) {
      caddyfile += `{
    email ${email}
    # Enable automatic HTTPS
    auto_https on
}

`;
    }

    // Domain block
    caddyfile += `${domain} {
    # Reverse proxy to backend service
    reverse_proxy ${serviceName}:${port}

`;

    // Add gzip encoding
    if (enableGzip) {
      caddyfile += `    # Enable gzip compression
    encode gzip

`;
    }

    // Add security headers
    caddyfile += `    # Security headers
    header {
        # Enable HSTS
        Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"

        # Prevent clickjacking
        X-Frame-Options "SAMEORIGIN"

        # Prevent MIME type sniffing
        X-Content-Type-Options "nosniff"

        # Enable XSS protection
        X-XSS-Protection "1; mode=block"

        # Referrer policy
        Referrer-Policy "no-referrer-when-downgrade"

        # Remove server header
        -Server
    }

`;

    // Add logging
    caddyfile += `    # Logging
    log {
        output file /var/log/caddy/${serviceName}.log
        format json
    }
}
`;

    return caddyfile;
  }

  /**
   * Generate global Caddyfile for multiple services
   */
  static generateGlobalCaddyfile(
    services: CaddyServiceConfig[],
    options: CaddyOptions = {}
  ): string {
    const {
      email,
      enableAutoHTTPS = true,
      logLevel = 'INFO',
    } = options;

    let caddyfile = `# Global Caddyfile for Multiple Services
# Generated by DevOps Deployment Accelerator

`;

    // Global configuration block
    caddyfile += `{
`;

    if (email && enableAutoHTTPS) {
      caddyfile += `    # Email for Let's Encrypt
    email ${email}

    # Enable automatic HTTPS
    auto_https on

`;
    }

    caddyfile += `    # Admin API
    admin 0.0.0.0:2019

    # Global log level
    log {
        level ${logLevel}
    }
}

`;

    // Generate configuration for each service
    services.forEach((service, index) => {
      const { serviceName, domain, port, path = '/' } = service;

      caddyfile += `# Service: ${serviceName}
${domain} {
    # Reverse proxy to ${serviceName}
    reverse_proxy ${serviceName}:${port}

    # Enable gzip compression
    encode gzip

    # Security headers
    header {
        Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
        X-Frame-Options "SAMEORIGIN"
        X-Content-Type-Options "nosniff"
        X-XSS-Protection "1; mode=block"
        Referrer-Policy "no-referrer-when-downgrade"
        -Server
    }

    # Logging
    log {
        output file /var/log/caddy/${serviceName}.log
        format json
    }
}

`;
    });

    return caddyfile;
  }

  /**
   * Generate Caddyfile with advanced routing and load balancing
   */
  static generateAdvancedCaddyfile(
    config: CaddyServiceConfig,
    options: CaddyOptions & {
      backends?: string[]; // Multiple backend servers for load balancing
      healthCheckPath?: string; // Health check endpoint
      healthCheckInterval?: string; // Health check interval (default: 30s)
    } = {}
  ): string {
    const {
      serviceName,
      domain,
      port,
      path = '/',
    } = config;

    const {
      email,
      enableAutoHTTPS = true,
      enableGzip = true,
      backends = [`${serviceName}:${port}`],
      healthCheckPath = '/health',
      healthCheckInterval = '30s',
    } = options;

    let caddyfile = `# Advanced Caddyfile for ${serviceName}
# Generated by DevOps Deployment Accelerator

`;

    // Global options
    if (email && enableAutoHTTPS) {
      caddyfile += `{
    email ${email}
    auto_https on
}

`;
    }

    // Domain block with load balancing
    caddyfile += `${domain} {
    # Reverse proxy with load balancing
    reverse_proxy `;

    // Add all backends
    caddyfile += backends.join(' ');

    caddyfile += ` {
        # Load balancing policy
        lb_policy round_robin

        # Health checks
        health_uri ${healthCheckPath}
        health_interval ${healthCheckInterval}
        health_timeout 5s

        # Retry policy
        lb_try_duration 5s
        lb_try_interval 250ms
    }

`;

    // Add encoding
    if (enableGzip) {
      caddyfile += `    # Compression
    encode gzip zstd

`;
    }

    // Add security headers
    caddyfile += `    # Security headers
    header {
        Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
        X-Frame-Options "SAMEORIGIN"
        X-Content-Type-Options "nosniff"
        X-XSS-Protection "1; mode=block"
        Referrer-Policy "no-referrer-when-downgrade"
        Content-Security-Policy "default-src 'self'"
        Permissions-Policy "geolocation=(self), microphone=()"
        -Server
    }

    # Rate limiting (optional)
    # rate_limit {
    #     zone dynamic {
    #         key {remote_host}
    #         events 100
    #         window 1m
    #     }
    # }

    # Logging with detailed format
    log {
        output file /var/log/caddy/${serviceName}.log {
            roll_size 10mb
            roll_keep 5
            roll_keep_days 7
        }
        format json
    }
}
`;

    return caddyfile;
  }

  /**
   * Generate Kubernetes ConfigMap with Caddyfile
   */
  static generateKubernetesConfigMap(
    configMapName: string,
    caddyfile: string,
    namespace: string = 'default'
  ): any {
    return {
      apiVersion: 'v1',
      kind: 'ConfigMap',
      metadata: {
        name: configMapName,
        namespace: namespace,
        labels: {
          app: 'caddy',
          component: 'proxy',
        },
      },
      data: {
        Caddyfile: caddyfile,
      },
    };
  }

  /**
   * Generate Kubernetes ConfigMap for a service
   */
  static generateServiceConfigMap(
    serviceName: string,
    config: CaddyServiceConfig,
    options: CaddyOptions = {},
    namespace: string = 'default'
  ): any {
    const caddyfile = this.generateCaddyfile(config, options);
    const configMapName = `${serviceName}-caddy-config`;

    return this.generateKubernetesConfigMap(
      configMapName,
      caddyfile,
      namespace
    );
  }

  /**
   * Export ConfigMap to YAML string
   */
  static exportConfigMapToYaml(configMap: any): string {
    return yaml.dump(configMap, {
      indent: 2,
      lineWidth: -1,
      noRefs: true,
    });
  }

  /**
   * Validate Caddy configuration
   */
  static validate(config: CaddyServiceConfig): {
    valid: boolean;
    errors: string[];
    warnings: string[];
  } {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Validate service name
    if (!config.serviceName || config.serviceName.trim() === '') {
      errors.push('Service name is required');
    }

    // Validate domain
    if (!config.domain || config.domain.trim() === '') {
      errors.push('Domain is required');
    } else if (!/^[a-zA-Z0-9][a-zA-Z0-9-_.]+[a-zA-Z0-9]$/.test(config.domain)) {
      warnings.push('Domain format may be invalid');
    }

    // Validate port
    if (!config.port || config.port < 1 || config.port > 65535) {
      errors.push('Port must be between 1 and 65535');
    }

    // Check for localhost/127.0.0.1 (Caddy won't issue certificates for these)
    if (config.domain === 'localhost' || config.domain.startsWith('127.')) {
      warnings.push('Caddy will not issue HTTPS certificates for localhost/127.0.0.1');
    }

    // Check for IP addresses (Caddy prefers domain names)
    if (/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(config.domain)) {
      warnings.push('Using IP address instead of domain name. HTTPS certificates may not work.');
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Generate Caddy service for Docker Compose
   */
  static generateDockerComposeService(
    services: CaddyServiceConfig[],
    options: CaddyOptions = {}
  ): any {
    return {
      caddy: {
        image: 'caddy:2-alpine',
        container_name: 'caddy-proxy',
        ports: [
          '80:80',
          '443:443',
          '2019:2019', // Admin API
        ],
        volumes: [
          './Caddyfile:/etc/caddy/Caddyfile:ro',
          './caddy/data:/data', // Certificate storage
          './caddy/config:/config', // Caddy configuration
          './caddy/logs:/var/log/caddy', // Logs
        ],
        restart: 'unless-stopped',
        networks: ['proxy'],
        depends_on: services.map(s => s.serviceName),
        environment: options.email
          ? {
              CADDY_ADMIN: '0.0.0.0:2019',
              ACME_EMAIL: options.email,
            }
          : {
              CADDY_ADMIN: '0.0.0.0:2019',
            },
      },
    };
  }

  /**
   * Generate path-based routing Caddyfile (multiple services on same domain)
   */
  static generatePathBasedRouting(
    domain: string,
    services: Array<CaddyServiceConfig & { pathPrefix: string }>,
    options: CaddyOptions = {}
  ): string {
    const { email, enableAutoHTTPS = true } = options;

    let caddyfile = `# Path-based Routing Caddyfile
# Generated by DevOps Deployment Accelerator

`;

    // Global options
    if (email && enableAutoHTTPS) {
      caddyfile += `{
    email ${email}
    auto_https on
}

`;
    }

    // Single domain with multiple path-based routes
    caddyfile += `${domain} {
    # Security headers
    header {
        Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
        X-Frame-Options "SAMEORIGIN"
        X-Content-Type-Options "nosniff"
        X-XSS-Protection "1; mode=block"
        -Server
    }

    # Enable compression
    encode gzip

`;

    // Add route for each service
    services.forEach(service => {
      const { serviceName, port, pathPrefix } = service;

      caddyfile += `    # Route for ${serviceName}
    handle ${pathPrefix}* {
        reverse_proxy ${serviceName}:${port}
    }

`;
    });

    // Fallback handler
    caddyfile += `    # Fallback for unmatched routes
    handle {
        respond "Not Found" 404
    }

    # Logging
    log {
        output file /var/log/caddy/access.log
        format json
    }
}
`;

    return caddyfile;
  }
}
