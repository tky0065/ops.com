import * as yaml from 'js-yaml';

/**
 * Nginx Configuration Options
 */
export interface NginxOptions {
  email?: string; // For SSL certificate (documentation purposes)
  enableSSL?: boolean; // Enable HTTPS configuration
  domains?: Record<string, string>; // serviceName -> domain mapping
  clientMaxBodySize?: string; // Max request body size (default: 10m)
  enableWebSocket?: boolean; // Enable WebSocket support
}

/**
 * Nginx Service Configuration
 */
export interface NginxServiceConfig {
  serviceName: string;
  domain: string;
  port: number;
  upstream?: string; // Custom upstream name
}

/**
 * Nginx Generator Class
 * Generates Nginx configurations for reverse proxy with SSL/TLS support
 */
export class NginxGenerator {
  /**
   * Generate complete nginx.conf for a single service
   */
  static generateConfig(
    config: NginxServiceConfig,
    options: NginxOptions = {}
  ): string {
    const {
      serviceName,
      domain,
      port,
      upstream = serviceName,
    } = config;

    const {
      enableSSL = true,
      clientMaxBodySize = '10m',
      enableWebSocket = true,
    } = options;

    const upstreamName = upstream.toLowerCase().replace(/[^a-z0-9_]/g, '_');

    let nginxConfig = `# Nginx configuration for ${serviceName}
# Generated by DevOps Deployment Accelerator

# Upstream backend definition
upstream ${upstreamName} {
    server ${serviceName}:${port};
    # Add additional backend servers here for load balancing
    # server ${serviceName}-2:${port};
    # server ${serviceName}-3:${port};
}

`;

    // HTTP Server Block (port 80)
    if (enableSSL) {
      // Redirect HTTP to HTTPS
      nginxConfig += `# HTTP Server - Redirect to HTTPS
server {
    listen 80;
    listen [::]:80;
    server_name ${domain};

    # ACME challenge location for Let's Encrypt
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }

    # Redirect all other traffic to HTTPS
    location / {
        return 301 https://$server_name$request_uri;
    }
}

`;
    } else {
      // HTTP only configuration
      nginxConfig += `# HTTP Server
server {
    listen 80;
    listen [::]:80;
    server_name ${domain};

    # Client request body size limit
    client_max_body_size ${clientMaxBodySize};

    # Proxy settings
    location / {
        proxy_pass http://${upstreamName};
        ${this.generateProxyHeaders(enableWebSocket)}
    }

    # Health check endpoint
    location /health {
        access_log off;
        proxy_pass http://${upstreamName}/health;
    }
}

`;
    }

    // HTTPS Server Block (port 443)
    if (enableSSL) {
      nginxConfig += `# HTTPS Server
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${domain};

    # SSL/TLS Configuration
    ssl_certificate /etc/nginx/ssl/${domain}/fullchain.pem;
    ssl_certificate_key /etc/nginx/ssl/${domain}/privkey.pem;

    # SSL Protocols and Ciphers (Modern Configuration)
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';
    ssl_prefer_server_ciphers off;

    # SSL Session Configuration
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_session_tickets off;

    # OCSP Stapling
    ssl_stapling on;
    ssl_stapling_verify on;
    ssl_trusted_certificate /etc/nginx/ssl/${domain}/chain.pem;

    # Security Headers
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;

    # Client request body size limit
    client_max_body_size ${clientMaxBodySize};

    # Proxy settings
    location / {
        proxy_pass http://${upstreamName};
        ${this.generateProxyHeaders(enableWebSocket)}
    }

    # Health check endpoint
    location /health {
        access_log off;
        proxy_pass http://${upstreamName}/health;
    }
}
`;
    }

    return nginxConfig;
  }

  /**
   * Generate proxy headers configuration
   */
  private static generateProxyHeaders(enableWebSocket: boolean): string {
    let headers = `proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port $server_port;`;

    if (enableWebSocket) {
      headers += `

        # WebSocket support
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_http_version 1.1;`;
    }

    return headers;
  }

  /**
   * Generate nginx.conf for multiple services
   */
  static generateMultiServiceConfig(
    services: NginxServiceConfig[],
    options: NginxOptions = {}
  ): string {
    let config = `# Nginx Multi-Service Configuration
# Generated by DevOps Deployment Accelerator

# Global settings
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
}

http {
    # Basic Settings
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # Logging
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    access_log /var/log/nginx/access.log main;

    # Performance
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # Gzip Compression
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript application/json application/javascript application/xml+rss application/rss+xml font/truetype font/opentype application/vnd.ms-fontobject image/svg+xml;

    # Security
    server_tokens off;

`;

    // Generate upstream blocks
    services.forEach(service => {
      const upstreamName = (service.upstream || service.serviceName)
        .toLowerCase()
        .replace(/[^a-z0-9_]/g, '_');

      config += `    # Upstream for ${service.serviceName}
    upstream ${upstreamName} {
        server ${service.serviceName}:${service.port};
    }

`;
    });

    config += `    # Include individual server configurations
    include /etc/nginx/conf.d/*.conf;
}\n`;

    return config;
  }

  /**
   * Generate Kubernetes ConfigMap with nginx.conf
   */
  static generateKubernetesConfigMap(
    configMapName: string,
    nginxConfig: string,
    namespace: string = 'default'
  ): any {
    return {
      apiVersion: 'v1',
      kind: 'ConfigMap',
      metadata: {
        name: configMapName,
        namespace: namespace,
        labels: {
          app: 'nginx',
          component: 'proxy',
        },
      },
      data: {
        'nginx.conf': nginxConfig,
      },
    };
  }

  /**
   * Generate Kubernetes ConfigMap for individual service config
   */
  static generateServiceConfigMap(
    serviceName: string,
    config: NginxServiceConfig,
    options: NginxOptions = {},
    namespace: string = 'default'
  ): any {
    const nginxConfig = this.generateConfig(config, options);
    const configMapName = `${serviceName}-nginx-config`;

    return this.generateKubernetesConfigMap(
      configMapName,
      nginxConfig,
      namespace
    );
  }

  /**
   * Export ConfigMap to YAML string
   */
  static exportConfigMapToYaml(configMap: any): string {
    return yaml.dump(configMap, {
      indent: 2,
      lineWidth: -1,
      noRefs: true,
    });
  }

  /**
   * Validate nginx configuration structure
   */
  static validate(config: NginxServiceConfig): {
    valid: boolean;
    errors: string[];
    warnings: string[];
  } {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Validate service name
    if (!config.serviceName || config.serviceName.trim() === '') {
      errors.push('Service name is required');
    }

    // Validate domain
    if (!config.domain || config.domain.trim() === '') {
      errors.push('Domain is required');
    } else if (!/^[a-zA-Z0-9][a-zA-Z0-9-_.]+[a-zA-Z0-9]$/.test(config.domain)) {
      warnings.push('Domain format may be invalid');
    }

    // Validate port
    if (!config.port || config.port < 1 || config.port > 65535) {
      errors.push('Port must be between 1 and 65535');
    }

    // Common port warnings
    if (config.port === 80 || config.port === 443) {
      warnings.push('Using standard HTTP/HTTPS port, ensure this is intentional');
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Generate nginx deployment configuration for Docker Compose
   */
  static generateDockerComposeService(
    services: NginxServiceConfig[],
    options: NginxOptions = {}
  ): any {
    return {
      nginx: {
        image: 'nginx:alpine',
        container_name: 'nginx-proxy',
        ports: [
          '80:80',
          ...(options.enableSSL !== false ? ['443:443'] : []),
        ],
        volumes: [
          './nginx/nginx.conf:/etc/nginx/nginx.conf:ro',
          './nginx/conf.d:/etc/nginx/conf.d:ro',
          ...(options.enableSSL !== false
            ? ['./nginx/ssl:/etc/nginx/ssl:ro', './certbot/www:/var/www/certbot:ro']
            : []
          ),
        ],
        restart: 'unless-stopped',
        networks: ['proxy'],
        depends_on: services.map(s => s.serviceName),
      },
    };
  }
}
